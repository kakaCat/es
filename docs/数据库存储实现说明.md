# 数据库存储实现说明

## 概述

为了提高元数据存储的可靠性和性能，我们将元数据存储从文件系统迁移到PostgreSQL数据库。新的实现支持数据库和文件系统的双存储模式，当数据库不可用时会自动回退到文件系统存储。

## 技术架构

### 数据库设计

我们创建了以下数据表来存储不同类型的元数据：

1. **tenant_containers** - 租户容器信息
2. **index_metadata** - 索引元数据
3. **tenant_quota** - 租户配额信息
4. **deployment_status** - 部署状态信息
5. **monitoring_metrics** - 监控指标
6. **container_metrics** - 容器指标

### 连接配置

数据库连接信息：
- Host: postgres
- Port: 5432
- Database: es_metadata
- Username: es_user
- Password: es_password_2025

## 实现细节

### 1. 双存储模式

新的MetadataService支持双存储模式：
- 主要使用PostgreSQL数据库存储
- 数据库不可用时自动回退到文件系统存储

```go
// 连接数据库
connStr := "host=postgres port=5432 user=es_user password=es_password_2025 dbname=es_metadata sslmode=disable"
DB, err := sql.Open("postgres", connStr)

// 如果数据库连接失败，回退到文件存储
if err != nil {
    log.Printf("Warning: Failed to connect to database: %v", err)
    return &MetadataService{dataDir: dataDir}
}
```

### 2. 数据操作

所有元数据操作都支持双存储：

#### 保存租户容器
```go
// 如果数据库可用，使用数据库存储
if ms.DB != nil {
    _, err := ms.DB.Exec(`
        INSERT INTO tenant_containers 
        (id, tenant_org_id, user_id, service_name, namespace, replicas, cpu, memory, disk, gpu_count, dimension, vector_count, status, created_at, sync_time, deleted)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
        ON CONFLICT (id) DO UPDATE SET
            tenant_org_id = EXCLUDED.tenant_org_id,
            // ... 其他字段更新
    `, container.ID, container.TenantOrgID, container.User, container.ServiceName, // ... 其他参数)
    
    return err
}

// 否则回退到文件存储
filename := filepath.Join(ms.dataDir, fmt.Sprintf("tenant_%s_%s.json", container.User, container.ServiceName))
// ... 文件存储逻辑
```

#### 查询租户容器
```go
// 如果数据库可用，使用数据库查询
if ms.DB != nil {
    var container TenantContainer
    err := ms.DB.QueryRow(`
        SELECT id, tenant_org_id, user_id, service_name, namespace, replicas, cpu, memory, disk, gpu_count, dimension, vector_count, status, created_at, sync_time, deleted
        FROM tenant_containers 
        WHERE user_id = $1 AND service_name = $2
    `, user, serviceName).Scan(
        &container.ID, &container.TenantOrgID, &container.User, &container.ServiceName, // ... 其他字段
    )
    
    // 检查逻辑删除标记
    if container.Deleted {
        return nil, fmt.Errorf("tenant container for user %s and service %s has been deleted", user, serviceName)
    }
    
    return &container, nil
}

// 否则回退到文件存储
filename := filepath.Join(ms.dataDir, fmt.Sprintf("tenant_%s_%s.json", user, serviceName))
// ... 文件读取逻辑
```

#### 逻辑删除
```go
// 如果数据库可用，使用数据库更新
if ms.DB != nil {
    _, err := ms.DB.Exec(`
        UPDATE tenant_containers 
        SET deleted = true, status = 'deleted', sync_time = $1
        WHERE user_id = $2 AND service_name = $3
    `, time.Now(), user, serviceName)
    return err
}

// 否则回退到文件存储
// ... 文件更新逻辑
```

## 部署配置

### Docker Compose

在docker-compose.yml中添加了PostgreSQL服务：

```yaml
postgres:
  image: postgres:15
  container_name: postgres
  environment:
    POSTGRES_DB: es_metadata
    POSTGRES_USER: es_user
    POSTGRES_PASSWORD: es_password_2025
  ports:
    - "5432:5432"
  volumes:
    - postgres-data:/var/lib/postgresql/data
    - ./init.sql:/docker-entrypoint-initdb.d/init.sql
  restart: unless-stopped
```

### 数据库初始化

通过init.sql脚本自动创建表结构和索引：

```sql
-- Tenant Containers table
CREATE TABLE IF NOT EXISTS tenant_containers (
    id VARCHAR(255) PRIMARY KEY,
    tenant_org_id VARCHAR(255) NOT NULL,
    user_id VARCHAR(255) NOT NULL,
    service_name VARCHAR(255) NOT NULL,
    // ... 其他字段
    deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- 创建索引以提高查询性能
CREATE INDEX IF NOT EXISTS idx_tenant_containers_user_service ON tenant_containers(user_id, service_name);
CREATE INDEX IF NOT EXISTS idx_tenant_containers_org ON tenant_containers(tenant_org_id);
CREATE INDEX IF NOT EXISTS idx_tenant_containers_deleted ON tenant_containers(deleted);
```

## 优势

1. **数据一致性**：数据库事务保证数据一致性
2. **查询性能**：索引优化提高查询速度
3. **可靠性**：数据库持久化存储提高数据安全性
4. **兼容性**：双存储模式确保向后兼容
5. **可扩展性**：支持未来添加更多元数据类型

## 注意事项

1. **回退机制**：当数据库不可用时会自动回退到文件系统存储
2. **逻辑删除**：仍然使用逻辑删除机制，保持与之前实现的一致性
3. **数据迁移**：现有文件系统中的数据需要手动迁移到数据库
4. **连接管理**：需要确保网络连接稳定以获得最佳性能